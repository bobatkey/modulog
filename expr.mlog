module type INPUT = sig
  type index

  type token

  is_index : index

  token_at : index * token * index
end

module type GRAMMAR = sig
  type non_terminal
  type token
  type rhs

  nt_to_rhs : non_terminal * rhs

  rhs_nt   : rhs * non_terminal * rhs
  rhs_tok  : rhs * token * rhs
  rhs_stop : rhs
end

module ExprGrammar = struct
  type non_terminal = [ `E ]

  type token = [ `x | `plus ]

  type rhs = [ `E1 | `E2 ] * int

  def nt_to_rhs : non_terminal * rhs
      nt_to_rhs (`E, (`E1,0))
      nt_to_rhs (`E, (`E2,0))

  def rhs_tok : rhs * token * rhs
      rhs_tok ((`E1,0), `x, (`E1,1))
      rhs_tok ((`E2,1), `plus, (`E2,2))

  def rhs_nt : rhs * non_terminal * rhs
      rhs_nt ((`E2,0), `E, (`E2,1))
      rhs_nt ((`E2,2), `E, (`E2,3))

  def rhs_stop : rhs
      rhs_stop ((`E1,1))
      rhs_stop ((`E2,3))
end

module Recogniser =
  functor (G : GRAMMAR) ->
  functor (I : sig type index
                   type token = G.token
                   token_at : index * token * index
                   is_index : index
               end) ->
struct

  def
    parse : I.index * G.non_terminal * I.index
    parse (i, nt, j) :- G.nt_to_rhs (nt, rhs), parse_rhs (i, rhs, j)

  and
    parse_rhs : I.index * G.rhs * I.index
    parse_rhs (i, rhs, i) :-
       G.rhs_stop (rhs), I.is_index (i)
    parse_rhs (i, rhs, j) :-
       G.rhs_tok (rhs, tok, rhs'), I.token_at (i, tok, i'), parse_rhs (i', rhs', j)
    parse_rhs (i, rhs, j) :-
       G.rhs_nt (rhs, nt, rhs'), parse (i, nt, i'), parse_rhs (i', rhs', j)

end

module TestInput = struct
  type index = int

  type token = [`x | `plus]

  def is_index : index
      is_index (0)
      is_index (1)
      is_index (2)
      is_index (3)

  def token_at : index * token * index
      token_at (0,`x,1)
      token_at (1,`plus,2)
      token_at (2,`x,3)
end

module R = Recogniser (ExprGrammar) (TestInput)

(*
module Grammar = functor (I : INPUT) -> struct

  def
    expr : I.index * I.index
    expr (i,j) :- I.token_at (i, 0, j)
    expr (i,j) :- expr (i,i1), I.token_at (i1,1,j1), expr (j1,j)

end

module G = Grammar (TestInput)
*)
