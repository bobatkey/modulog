program: CONSTANT IDENT COLON INT EQUALS IDENT WITH 
##
## Ends in an error in state: 111.
##
## expr -> longident . [ TYPE RPAREN MODULE EXTERNAL EOF END DEFINE CONSTANT COMMA ]
## longident -> longident . DOT IDENT [ TYPE RPAREN MODULE EXTERNAL EOF END DOT DEFINE CONSTANT COMMA ]
##
## The known suffix of the stack is as follows:
## longident 
##

having read a identifier in an expression, expecting either a new declaration or a '.' followed by an identifier.

program: CONSTANT IDENT COLON INT EQUALS LPAREN WITH 
##
## Ends in an error in state: 105.
##
## expr -> LPAREN . loption(separated_nonempty_list(COMMA,expr)) RPAREN [ TYPE RPAREN MODULE EXTERNAL EOF END DEFINE CONSTANT COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

expecting either a closing ')' or a comma separated list of expressions followed by a ')'.

program: CONSTANT IDENT COLON INT EQUALS WITH 
##
## Ends in an error in state: 139.
##
## str_value -> CONSTANT IDENT COLON domain_type EQUALS . expr [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## CONSTANT IDENT COLON domain_type EQUALS 
##

expecting an expresson after $4 $3 $2 $1 $0.

program: CONSTANT IDENT COLON INT WITH 
##
## Ends in an error in state: 138.
##
## str_value -> CONSTANT IDENT COLON domain_type . EQUALS expr [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## CONSTANT IDENT COLON domain_type 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 19, spurious reduction of production separated_nonempty_list(STAR,domain_type0) -> domain_type0 
## In state 15, spurious reduction of production domain_type -> separated_nonempty_list(STAR,domain_type0) 
##

when parsing the declaration of the constant $2, the type $0 has been understood. If this is the end of the type then an '=' is expected next before the definition of $2. For example:
  constant cname : int = 5

program: CONSTANT IDENT COLON WITH 
##
## Ends in an error in state: 137.
##
## str_value -> CONSTANT IDENT COLON . domain_type EQUALS expr [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## CONSTANT IDENT COLON 
##

expecting a type after the ':' in a constant declaration after $2 $1 $0.

program: CONSTANT IDENT WITH 
##
## Ends in an error in state: 136.
##
## str_value -> CONSTANT IDENT . COLON domain_type EQUALS expr [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## CONSTANT IDENT 
##

expecting a type annotation (": <type>") on constant declaration after $1 $0.

program: CONSTANT WITH 
##
## Ends in an error in state: 135.
##
## str_value -> CONSTANT . IDENT COLON domain_type EQUALS expr [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## CONSTANT 
##

expecting an identifier after Â£0.

program: DEFINE IDENT COLON IDENT AND WITH 
##
## Ends in an error in state: 131.
##
## list(__anonymous_0) -> AND . pred_decl list(__anonymous_0) [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## AND 
##

expecting additional predicate declarations after an 'and'.

program: DEFINE IDENT COLON INT IDENT LPAREN RPAREN COLON_DASH IDENT LPAREN RPAREN COMMA WITH 
##
## Ends in an error in state: 127.
##
## separated_nonempty_list(COMMA,atom) -> atom COMMA . separated_nonempty_list(COMMA,atom) [ TYPE MODULE IDENT EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## atom COMMA 
##

expecting additional atoms after the $0.

program: DEFINE IDENT COLON INT IDENT LPAREN RPAREN COLON_DASH IDENT LPAREN RPAREN WITH 
##
## Ends in an error in state: 126.
##
## separated_nonempty_list(COMMA,atom) -> atom . [ TYPE MODULE IDENT EXTERNAL EOF END DEFINE CONSTANT AND ]
## separated_nonempty_list(COMMA,atom) -> atom . COMMA separated_nonempty_list(COMMA,atom) [ TYPE MODULE IDENT EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## atom 
##

after the atom $0, expecting a new declaration or a comma and additional atoms.

program: DEFINE IDENT COLON INT IDENT LPAREN RPAREN COLON_DASH IDENT LPAREN WITH 
##
## Ends in an error in state: 123.
##
## atom -> longident LPAREN . loption(separated_nonempty_list(COMMA,expr)) RPAREN [ TYPE MODULE IDENT EXTERNAL EOF END DEFINE CONSTANT COMMA AND ]
##
## The known suffix of the stack is as follows:
## longident LPAREN 
##

expecting either an expression or a closing parenthesis in the argument list for the predicate $1.

program: DEFINE IDENT COLON INT IDENT LPAREN RPAREN COLON_DASH IDENT WITH 
##
## Ends in an error in state: 122.
##
## atom -> longident . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN [ TYPE MODULE IDENT EXTERNAL EOF END DEFINE CONSTANT COMMA AND ]
## longident -> longident . DOT IDENT [ LPAREN DOT ]
##
## The known suffix of the stack is as follows:
## longident 
##

expecting either an argument list, or an long predicate identifier.

program: DEFINE IDENT COLON INT IDENT LPAREN RPAREN COLON_DASH WITH 
##
## Ends in an error in state: 120.
##
## rule -> decl_head COLON_DASH . separated_nonempty_list(COMMA,atom) [ TYPE MODULE IDENT EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## decl_head COLON_DASH 
##

expecting a comma separated list of atoms after a ':-' in a rule declaration.

program: DEFINE IDENT COLON INT IDENT LPAREN RPAREN WITH 
##
## Ends in an error in state: 119.
##
## rule -> decl_head . COLON_DASH separated_nonempty_list(COMMA,atom) [ TYPE MODULE IDENT EXTERNAL EOF END DEFINE CONSTANT AND ]
## rule -> decl_head . [ TYPE MODULE IDENT EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## decl_head 
##

expecting either a list of clauses (':- a(..), b(...)') or a new declaration after a rule head.

program: DEFINE IDENT COLON INT IDENT LPAREN UNDERSCORE COMMA WITH 
##
## Ends in an error in state: 113.
##
## separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr COMMA 
##

expecting an expression after the comma.

program: DEFINE IDENT COLON INT IDENT LPAREN UNDERSCORE WITH 
##
## Ends in an error in state: 112.
##
## separated_nonempty_list(COMMA,expr) -> expr . [ RPAREN ]
## separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr 
##

expecting either a closing parenthesis ')', or a comma followed by more expressions.

program: DEFINE IDENT COLON INT IDENT LPAREN WITH 
##
## Ends in an error in state: 102.
##
## decl_head -> IDENT LPAREN . loption(separated_nonempty_list(COMMA,expr)) RPAREN [ TYPE MODULE IDENT EXTERNAL EOF END DEFINE CONSTANT COLON_DASH AND ]
##
## The known suffix of the stack is as follows:
## IDENT LPAREN 
##

expecting either a closing parenthesis ')', or a comma separated list of expressions followed by a ')'.

program: DEFINE IDENT COLON INT IDENT WITH 
##
## Ends in an error in state: 101.
##
## decl_head -> IDENT . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN [ TYPE MODULE IDENT EXTERNAL EOF END DEFINE CONSTANT COLON_DASH AND ]
##
## The known suffix of the stack is as follows:
## IDENT 
##

expecting an argument list in parentheses for this rule head.

program: DEFINE IDENT COLON INT WITH 
##
## Ends in an error in state: 100.
##
## pred_decl -> IDENT COLON predicate_type . list(rule) [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## IDENT COLON predicate_type 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 19, spurious reduction of production separated_nonempty_list(STAR,domain_type0) -> domain_type0 
## In state 37, spurious reduction of production predicate_type -> separated_nonempty_list(STAR,domain_type0) 
##

after the type declaration for this predicate, expecting either a list of rules or a new declaration.

program: DEFINE IDENT COLON WITH 
##
## Ends in an error in state: 99.
##
## pred_decl -> IDENT COLON . predicate_type list(rule) [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## IDENT COLON 
##

expecting a type declaration following the colon.

program: DEFINE IDENT WITH 
##
## Ends in an error in state: 98.
##
## pred_decl -> IDENT . COLON predicate_type list(rule) [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## IDENT 
##

expecting a colon followed by a type declaration.

program: DEFINE WITH 
##
## Ends in an error in state: 97.
##
## str_value -> DEFINE . pred_decl list(__anonymous_0) [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## DEFINE 
##

expecting an identifier after 'define'.

program: EXTERNAL IDENT COLON WITH 
##
## Ends in an error in state: 95.
##
## str_value -> EXTERNAL IDENT COLON . predicate_type [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## EXTERNAL IDENT COLON 
##

expecting a type declaration for this external predicate declaration.

program: EXTERNAL IDENT WITH 
##
## Ends in an error in state: 94.
##
## str_value -> EXTERNAL IDENT . COLON predicate_type [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## EXTERNAL IDENT 
##

expecting a colon followed by a type declaration for this external predicate declaration.

program: EXTERNAL WITH 
##
## Ends in an error in state: 93.
##
## str_value -> EXTERNAL . IDENT COLON predicate_type [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## EXTERNAL 
##

expecting a predicate name after an 'external' declaration.

program: MODULE IDENT EQUALS FUNCTOR LPAREN IDENT COLON IDENT RPAREN ARROW WITH 
##
## Ends in an error in state: 154.
##
## mod_term -> FUNCTOR LPAREN IDENT COLON mod_type RPAREN ARROW . mod_term [ TYPE RPAREN MODULE EXTERNAL EOF END DEFINE CONSTANT COLON ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN IDENT COLON mod_type RPAREN ARROW 
##

expecting a module term after the '->' in a functor expression.

program: MODULE IDENT EQUALS FUNCTOR LPAREN IDENT COLON IDENT RPAREN WITH 
##
## Ends in an error in state: 153.
##
## mod_term -> FUNCTOR LPAREN IDENT COLON mod_type RPAREN . ARROW mod_term [ TYPE RPAREN MODULE EXTERNAL EOF END DEFINE CONSTANT COLON ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN IDENT COLON mod_type RPAREN 
##

expecting an '->' after the parameter specification in a functor expression.

program: MODULE IDENT EQUALS FUNCTOR LPAREN IDENT COLON IDENT TYPE 
##
## Ends in an error in state: 152.
##
## mod_term -> FUNCTOR LPAREN IDENT COLON mod_type . RPAREN ARROW mod_term [ TYPE RPAREN MODULE EXTERNAL EOF END DEFINE CONSTANT COLON ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN IDENT COLON mod_type 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 62, spurious reduction of production mod_type2 -> longident 
## In state 48, spurious reduction of production mod_type -> mod_type2 
##

the module type $0 has been read for the functor parameter declaration. If this is the end of the type then there should be a closing ')'.

program: MODULE IDENT EQUALS FUNCTOR LPAREN IDENT COLON WITH 
##
## Ends in an error in state: 151.
##
## mod_term -> FUNCTOR LPAREN IDENT COLON . mod_type RPAREN ARROW mod_term [ TYPE RPAREN MODULE EXTERNAL EOF END DEFINE CONSTANT COLON ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN IDENT COLON 
##

expecting a module type after the ':' in a functor parameter specification.

program: MODULE IDENT EQUALS FUNCTOR LPAREN IDENT WITH 
##
## Ends in an error in state: 150.
##
## mod_term -> FUNCTOR LPAREN IDENT . COLON mod_type RPAREN ARROW mod_term [ TYPE RPAREN MODULE EXTERNAL EOF END DEFINE CONSTANT COLON ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN IDENT 
##

expecting a ':' after the parameter name.

program: MODULE IDENT EQUALS FUNCTOR LPAREN WITH 
##
## Ends in an error in state: 149.
##
## mod_term -> FUNCTOR LPAREN . IDENT COLON mod_type RPAREN ARROW mod_term [ TYPE RPAREN MODULE EXTERNAL EOF END DEFINE CONSTANT COLON ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN 
##

expecting a parameter name after 'functor ('.

program: MODULE IDENT EQUALS FUNCTOR WITH 
##
## Ends in an error in state: 148.
##
## mod_term -> FUNCTOR . LPAREN IDENT COLON mod_type RPAREN ARROW mod_term [ TYPE RPAREN MODULE EXTERNAL EOF END DEFINE CONSTANT COLON ]
##
## The known suffix of the stack is as follows:
## FUNCTOR 
##

expecting a parameter specification after 'functor'. FIXME: an example.

program: MODULE IDENT EQUALS IDENT AND 
##
## Ends in an error in state: 155.
##
## mod_term -> mod_term2 . [ TYPE RPAREN MODULE EXTERNAL EOF END DEFINE CONSTANT COLON ]
## mod_term2 -> mod_term2 . LPAREN mod_term RPAREN [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON ]
##
## The known suffix of the stack is as follows:
## mod_term2 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 159, spurious reduction of production mod_term2 -> longident 
##

having read the module term $0, expecting more declarations or a functor application parameter.

program: MODULE IDENT EQUALS IDENT COLON 
##
## Ends in an error in state: 143.
##
## list(str_item) -> str_item . list(str_item) [ EOF END ]
##
## The known suffix of the stack is as follows:
## str_item 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 159, spurious reduction of production mod_term2 -> longident 
## In state 155, spurious reduction of production mod_term -> mod_term2 
## In state 178, spurious reduction of production functor_decls -> EQUALS mod_term 
## In state 180, spurious reduction of production str_item -> MODULE IDENT functor_decls 
##

the declaration $0 has been read; expecting either more declarations, a terminating 'end', or the end of the input (if not within a struct).

program: MODULE IDENT EQUALS IDENT LPAREN IDENT TYPE 
##
## Ends in an error in state: 157.
##
## mod_term2 -> mod_term2 LPAREN mod_term . RPAREN [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON AND ]
##
## The known suffix of the stack is as follows:
## mod_term2 LPAREN mod_term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 159, spurious reduction of production mod_term2 -> longident 
## In state 155, spurious reduction of production mod_term -> mod_term2 
##

having read the module term $0, expecting to see a closing ')' to complete this functor application term.

program: MODULE IDENT EQUALS IDENT LPAREN WITH 
##
## Ends in an error in state: 156.
##
## mod_term2 -> mod_term2 LPAREN . mod_term RPAREN [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON AND ]
##
## The known suffix of the stack is as follows:
## mod_term2 LPAREN 
##

expecting a module term expression as a functor argument after the $0.

program: MODULE IDENT EQUALS IDENT WITH 
##
## Ends in an error in state: 159.
##
## longident -> longident . DOT IDENT [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DOT DEFINE CONSTANT COLON AND ]
## mod_term2 -> longident . [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON AND ]
##
## The known suffix of the stack is as follows:
## longident 
##

unexpected input following the long identifier $0 in a module term expression.

program: MODULE IDENT EQUALS LPAREN IDENT COLON IDENT TYPE 
##
## Ends in an error in state: 164.
##
## mod_term2 -> LPAREN mod_term COLON mod_type . RPAREN [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON AND ]
##
## The known suffix of the stack is as follows:
## LPAREN mod_term COLON mod_type 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 62, spurious reduction of production mod_type2 -> longident 
## In state 48, spurious reduction of production mod_type -> mod_type2 
##

having read the module type $0 in this module type constraint expression, expecting to see a closing ')'.

program: MODULE IDENT EQUALS LPAREN IDENT COLON WITH 
##
## Ends in an error in state: 163.
##
## mod_term2 -> LPAREN mod_term COLON . mod_type RPAREN [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON AND ]
##
## The known suffix of the stack is as follows:
## LPAREN mod_term COLON 
##

expecting to see a module type after the $0 in a module type constraint expression.

program: MODULE IDENT EQUALS LPAREN IDENT TYPE 
##
## Ends in an error in state: 161.
##
## mod_term2 -> LPAREN mod_term . COLON mod_type RPAREN [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON AND ]
## mod_term2 -> LPAREN mod_term . RPAREN [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON AND ]
##
## The known suffix of the stack is as follows:
## LPAREN mod_term 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 159, spurious reduction of production mod_term2 -> longident 
## In state 155, spurious reduction of production mod_term -> mod_term2 
##

after reading a $1 and the module term $0, expecting to see a closing ')', or a ':' (if this is a module type constraint term).

program: MODULE IDENT EQUALS LPAREN WITH 
##
## Ends in an error in state: 147.
##
## mod_term2 -> LPAREN . mod_term COLON mod_type RPAREN [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON AND ]
## mod_term2 -> LPAREN . mod_term RPAREN [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON AND ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

expecting a module term after the '('.

program: MODULE IDENT EQUALS STRUCT TYPE IDENT EQUALS IDENT EOF 
##
## Ends in an error in state: 145.
##
## mod_term2 -> STRUCT list(str_item) . END [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON AND ]
##
## The known suffix of the stack is as follows:
## STRUCT list(str_item) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production domain_type0 -> longident 
## In state 19, spurious reduction of production separated_nonempty_list(STAR,domain_type0) -> domain_type0 
## In state 15, spurious reduction of production domain_type -> separated_nonempty_list(STAR,domain_type0) 
## In state 24, spurious reduction of production str_type(IDENT) -> TYPE IDENT EQUALS domain_type 
## In state 142, spurious reduction of production str_item -> str_type(IDENT) 
## In state 143, spurious reduction of production list(str_item) -> 
## In state 144, spurious reduction of production list(str_item) -> str_item list(str_item) 
##

One or more declarations have been read in this structure, but it seems to end abruptly. Did you forget an 'end'?

program: MODULE IDENT EQUALS STRUCT WITH 
##
## Ends in an error in state: 92.
##
## mod_term2 -> STRUCT . list(str_item) END [ TYPE RPAREN MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT COLON AND ]
##
## The known suffix of the stack is as follows:
## STRUCT 
##

expecting a structure item after a 'struct'. Structure items look like FIXME.

program: MODULE IDENT EQUALS WITH 
##
## Ends in an error in state: 177.
##
## functor_decls -> EQUALS . mod_term [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## EQUALS 
##

expecting a module term after the '=' for this module definition.

program: MODULE IDENT LPAREN IDENT COLON IDENT RPAREN WITH 
##
## Ends in an error in state: 176.
##
## functor_decls -> LPAREN IDENT COLON mod_type RPAREN . functor_decls [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN IDENT COLON mod_type RPAREN 
##

expecting more functor parameter declarations or an '=' followed by a module term.

program: MODULE IDENT LPAREN IDENT COLON IDENT TYPE 
##
## Ends in an error in state: 175.
##
## functor_decls -> LPAREN IDENT COLON mod_type . RPAREN functor_decls [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN IDENT COLON mod_type 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 62, spurious reduction of production mod_type2 -> longident 
## In state 48, spurious reduction of production mod_type -> mod_type2 
##

have read a module type for the parameter of a functor declaration. If this is the end of the module type, insert a ')' here.

program: MODULE IDENT LPAREN IDENT COLON WITH 
##
## Ends in an error in state: 174.
##
## functor_decls -> LPAREN IDENT COLON . mod_type RPAREN functor_decls [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN IDENT COLON 
##

expecting a module type after the ':' in a functor parameter declaration.

program: MODULE IDENT LPAREN IDENT WITH 
##
## Ends in an error in state: 173.
##
## functor_decls -> LPAREN IDENT . COLON mod_type RPAREN functor_decls [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN IDENT 
##

expecting a ':' and a module type after the identifier in a functor parameter declaration.

program: MODULE IDENT LPAREN WITH 
##
## Ends in an error in state: 172.
##
## functor_decls -> LPAREN . IDENT COLON mod_type RPAREN functor_decls [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

expecting an identifier after the '(' in a functor parameter declaration.

program: MODULE IDENT WITH 
##
## Ends in an error in state: 171.
##
## str_item -> MODULE IDENT . functor_decls [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## MODULE IDENT 
##

after 'module $0', expecting an optional list of functor parameter declarations followed by a '='.

program: MODULE REC IDENT COLON IDENT EQUALS IDENT AND WITH 
##
## Ends in an error in state: 169.
##
## separated_nonempty_list(AND,rec_module_binding) -> rec_module_binding AND . separated_nonempty_list(AND,rec_module_binding) [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## rec_module_binding AND 
##

expecting further recursive module bindings after $0.

program: MODULE REC IDENT COLON IDENT EQUALS IDENT RPAREN 
##
## Ends in an error in state: 166.
##
## mod_term2 -> mod_term2 . LPAREN mod_term RPAREN [ TYPE MODULE LPAREN EXTERNAL EOF END DEFINE CONSTANT AND ]
## rec_module_binding -> IDENT COLON mod_type EQUALS mod_term2 . [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## IDENT COLON mod_type EQUALS mod_term2 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 159, spurious reduction of production mod_term2 -> longident 
##

unexpected input after having read the module term $0 in a recursive module binding.

program: MODULE REC IDENT COLON IDENT EQUALS WITH 
##
## Ends in an error in state: 91.
##
## rec_module_binding -> IDENT COLON mod_type EQUALS . mod_term2 [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## IDENT COLON mod_type EQUALS 
##

expecting a module term after the $0 in the recursive module binding for $3.

program: MODULE REC IDENT COLON IDENT TYPE 
##
## Ends in an error in state: 90.
##
## rec_module_binding -> IDENT COLON mod_type . EQUALS mod_term2 [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## IDENT COLON mod_type 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 62, spurious reduction of production mod_type2 -> longident 
## In state 48, spurious reduction of production mod_type -> mod_type2 
##

having read the module type $0 for the recursive module binding $2, expecting to see am '=' followed by a module term.

program: MODULE REC IDENT COLON WITH 
##
## Ends in an error in state: 89.
##
## rec_module_binding -> IDENT COLON . mod_type EQUALS mod_term2 [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## IDENT COLON 
##

expecting to see a module type following the $0 for the recursive module binding $1.

program: MODULE REC IDENT WITH 
##
## Ends in an error in state: 88.
##
## rec_module_binding -> IDENT . COLON mod_type EQUALS mod_term2 [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## IDENT 
##

expecting to see a ':' followed by a module type for the recursive module binding $0.

program: MODULE REC WITH 
##
## Ends in an error in state: 87.
##
## str_item -> MODULE REC . separated_nonempty_list(AND,rec_module_binding) [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## MODULE REC 
##

expecting to see an identifier after $1 $0.

program: MODULE TYPE IDENT EQUALS FUNCTOR LPAREN IDENT COLON IDENT RPAREN ARROW WITH 
##
## Ends in an error in state: 60.
##
## mod_type -> FUNCTOR LPAREN IDENT COLON mod_type RPAREN ARROW . mod_type [ TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN IDENT COLON mod_type RPAREN ARROW 
##

expecting to see a module type expression after a 'functor (...) -> '. FIXME: use multi-symbol input quoting here.

program: MODULE TYPE IDENT EQUALS FUNCTOR LPAREN IDENT COLON IDENT RPAREN WITH 
##
## Ends in an error in state: 59.
##
## mod_type -> FUNCTOR LPAREN IDENT COLON mod_type RPAREN . ARROW mod_type [ TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN IDENT COLON mod_type RPAREN 
##

expecting to see a '->' after 'functor (...)'. FIXME: use multi-symbol input quoting here.

program: MODULE TYPE IDENT EQUALS FUNCTOR LPAREN IDENT COLON IDENT TYPE 
##
## Ends in an error in state: 58.
##
## mod_type -> FUNCTOR LPAREN IDENT COLON mod_type . RPAREN ARROW mod_type [ TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN IDENT COLON mod_type 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 62, spurious reduction of production mod_type2 -> longident 
## In state 48, spurious reduction of production mod_type -> mod_type2 
##

have read the module type $0 for the functor parameter $2, now expecting to see a closing ')'.

program: MODULE TYPE IDENT EQUALS FUNCTOR LPAREN IDENT COLON WITH 
##
## Ends in an error in state: 47.
##
## mod_type -> FUNCTOR LPAREN IDENT COLON . mod_type RPAREN ARROW mod_type [ TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN IDENT COLON 
##

expecting to see a module type after the $3 $2 $1 $0 in a functor type expression.

program: MODULE TYPE IDENT EQUALS FUNCTOR LPAREN IDENT WITH 
##
## Ends in an error in state: 46.
##
## mod_type -> FUNCTOR LPAREN IDENT . COLON mod_type RPAREN ARROW mod_type [ TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN IDENT 
##

expecting to see a ':' followed by a module type after the $2 $1 $0 in a functor type expression.

program: MODULE TYPE IDENT EQUALS FUNCTOR LPAREN WITH 
##
## Ends in an error in state: 45.
##
## mod_type -> FUNCTOR LPAREN . IDENT COLON mod_type RPAREN ARROW mod_type [ TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## FUNCTOR LPAREN 
##

expecting to see an identifier for this functor parameter after $1 $0 in a functor type expression.

program: MODULE TYPE IDENT EQUALS FUNCTOR WITH 
##
## Ends in an error in state: 44.
##
## mod_type -> FUNCTOR . LPAREN IDENT COLON mod_type RPAREN ARROW mod_type [ TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## FUNCTOR 
##

expecting to see a '(' after $0 in a functor type expression.

program: MODULE TYPE IDENT EQUALS IDENT UNDERSCORE 
##
## Ends in an error in state: 62.
##
## longident -> longident . DOT IDENT [ WITH TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DOT DEFINE CONSTANT ]
## mod_type2 -> longident . [ WITH TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## longident 
##

unexpected input following the identifier $0 in a module type.

program: MODULE TYPE IDENT EQUALS IDENT WITH TYPE IDENT DOT WITH 
##
## Ends in an error in state: 52.
##
## separated_nonempty_list(DOT,IDENT) -> IDENT DOT . separated_nonempty_list(DOT,IDENT) [ EQUALS ]
##
## The known suffix of the stack is as follows:
## IDENT DOT 
##

expecting an identifier after $1 $0 in this path expression.

program: MODULE TYPE IDENT EQUALS IDENT WITH TYPE IDENT EQUALS WITH 
##
## Ends in an error in state: 55.
##
## str_type(separated_nonempty_list(DOT,IDENT)) -> TYPE separated_nonempty_list(DOT,IDENT) EQUALS . domain_type [ WITH TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## TYPE separated_nonempty_list(DOT,IDENT) EQUALS 
##

expecting a type after $2 $1 $0 in this 'with type' constraint.

program: MODULE TYPE IDENT EQUALS IDENT WITH TYPE IDENT WITH 
##
## Ends in an error in state: 51.
##
## separated_nonempty_list(DOT,IDENT) -> IDENT . [ EQUALS ]
## separated_nonempty_list(DOT,IDENT) -> IDENT . DOT separated_nonempty_list(DOT,IDENT) [ EQUALS ]
##
## The known suffix of the stack is as follows:
## IDENT 
##

expecting a '.'-separated path to be followed by '= <type>'.

program: MODULE TYPE IDENT EQUALS IDENT WITH TYPE WITH 
##
## Ends in an error in state: 50.
##
## str_type(separated_nonempty_list(DOT,IDENT)) -> TYPE . separated_nonempty_list(DOT,IDENT) EQUALS domain_type [ WITH TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## TYPE 
##

expecting a '.'-separated path to a type after 'with type'.

program: MODULE TYPE IDENT EQUALS IDENT WITH WITH 
##
## Ends in an error in state: 49.
##
## mod_type2 -> mod_type2 WITH . str_type(separated_nonempty_list(DOT,IDENT)) [ WITH TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## mod_type2 WITH 
##

expecting 'type <path> = <type>' after $0 in a module type.

program: MODULE TYPE IDENT EQUALS LPAREN IDENT TYPE 
##
## Ends in an error in state: 63.
##
## mod_type2 -> LPAREN mod_type . RPAREN [ WITH TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN mod_type 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 62, spurious reduction of production mod_type2 -> longident 
## In state 48, spurious reduction of production mod_type -> mod_type2 
##

a module type $0 has been read, if this type is complete then a closing ')' is expected.

program: MODULE TYPE IDENT EQUALS LPAREN WITH 
##
## Ends in an error in state: 43.
##
## mod_type2 -> LPAREN . mod_type RPAREN [ WITH TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

expecting a module type expression after $0. FIXME give examples.

program: MODULE TYPE IDENT EQUALS SIG CONSTANT IDENT COLON WITH 
##
## Ends in an error in state: 78.
##
## sig_value -> CONSTANT IDENT COLON . domain_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## CONSTANT IDENT COLON 
##

expecting a type after $2 $1 $0.

program: MODULE TYPE IDENT EQUALS SIG CONSTANT IDENT WITH 
##
## Ends in an error in state: 77.
##
## sig_value -> CONSTANT IDENT . COLON domain_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## CONSTANT IDENT 
##

expecting a ':' after $1 $0, followed by a type for this constant.

program: MODULE TYPE IDENT EQUALS SIG CONSTANT WITH 
##
## Ends in an error in state: 76.
##
## sig_value -> CONSTANT . IDENT COLON domain_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## CONSTANT 
##

expecting an identifier after $0.

program: MODULE TYPE IDENT EQUALS SIG END UNDERSCORE 
##
## Ends in an error in state: 48.
##
## mod_type -> mod_type2 . [ TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
## mod_type2 -> mod_type2 . WITH str_type(separated_nonempty_list(DOT,IDENT)) [ WITH TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## mod_type2 
##

unexpected input after a the module type expression $0.

program: MODULE TYPE IDENT EQUALS SIG PRED IDENT COLON IDENT WITH 
##
## Ends in an error in state: 82.
##
## list(sig_item) -> sig_item . list(sig_item) [ END ]
##
## The known suffix of the stack is as follows:
## sig_item 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production domain_type0 -> longident 
## In state 19, spurious reduction of production separated_nonempty_list(STAR,domain_type0) -> domain_type0 
## In state 37, spurious reduction of production predicate_type -> separated_nonempty_list(STAR,domain_type0) 
## In state 38, spurious reduction of production sig_value -> PRED IDENT COLON predicate_type 
## In state 80, spurious reduction of production sig_item -> sig_value 
##

a module signature item $0 has been read, expecting to see either another signature item, or a continuation of this item.

program: MODULE TYPE IDENT EQUALS SIG PRED IDENT COLON WITH 
##
## Ends in an error in state: 36.
##
## sig_value -> PRED IDENT COLON . predicate_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## PRED IDENT COLON 
##

expecting a predicate type after $2 $1 $0.

program: MODULE TYPE IDENT EQUALS SIG PRED IDENT WITH 
##
## Ends in an error in state: 35.
##
## sig_value -> PRED IDENT . COLON predicate_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## PRED IDENT 
##

expecting a ':' followed by a predicate type after the declaration of the predicate $0.

program: MODULE TYPE IDENT EQUALS SIG MODULE IDENT COLON WITH 
##
## Ends in an error in state: 72.
##
## functor_type_decls -> COLON . mod_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## COLON 
##

expecting a module type expression after the $0.

program: MODULE TYPE IDENT EQUALS SIG MODULE IDENT LPAREN IDENT COLON IDENT RPAREN WITH 
##
## Ends in an error in state: 71.
##
## functor_type_decls -> LPAREN IDENT COLON mod_type RPAREN . functor_type_decls [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN IDENT COLON mod_type RPAREN 
##

expecting either an ':' followed by a module type, or another functor parameter declaration.

program: MODULE TYPE IDENT EQUALS SIG MODULE IDENT LPAREN IDENT COLON IDENT TYPE 
##
## Ends in an error in state: 70.
##
## functor_type_decls -> LPAREN IDENT COLON mod_type . RPAREN functor_type_decls [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN IDENT COLON mod_type 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 62, spurious reduction of production mod_type2 -> longident 
## In state 48, spurious reduction of production mod_type -> mod_type2 
##

in a functor parameter declaration, the module type $0 for the parameter $2 has been read. If this is the complete type for this parameter, it should be followed by a closing ')'.

program: MODULE TYPE IDENT EQUALS SIG MODULE IDENT LPAREN IDENT COLON WITH 
##
## Ends in an error in state: 69.
##
## functor_type_decls -> LPAREN IDENT COLON . mod_type RPAREN functor_type_decls [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN IDENT COLON 
##

expecting a module type expression after a ':' in a functor parameter declaration.

program: MODULE TYPE IDENT EQUALS SIG MODULE IDENT LPAREN IDENT WITH 
##
## Ends in an error in state: 68.
##
## functor_type_decls -> LPAREN IDENT . COLON mod_type RPAREN functor_type_decls [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN IDENT 
##

expecting a ':' followed by a module type in functor parameter declaration.

program: MODULE TYPE IDENT EQUALS SIG MODULE IDENT LPAREN WITH 
##
## Ends in an error in state: 67.
##
## functor_type_decls -> LPAREN . IDENT COLON mod_type RPAREN functor_type_decls [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

expecting a module identifier after the '(' in a functor parameter declaration.

program: MODULE TYPE IDENT EQUALS SIG MODULE IDENT WITH 
##
## Ends in an error in state: 66.
##
## sig_item -> MODULE IDENT . functor_type_decls [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## MODULE IDENT 
##

after "module $0" in a signature, expecting an list of zero or more functor parameter declarations, followed by an ':' and a module type.

program: MODULE TYPE IDENT EQUALS SIG MODULE TYPE IDENT EQUALS WITH 
##
## Ends in an error in state: 42.
##
## sig_item -> MODULE TYPE IDENT EQUALS . mod_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## MODULE TYPE IDENT EQUALS 
##

expecting a module type expression after 'module type $1 ='.

program: MODULE TYPE IDENT EQUALS SIG MODULE TYPE IDENT WITH 
##
## Ends in an error in state: 41.
##
## sig_item -> MODULE TYPE IDENT . EQUALS mod_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## MODULE TYPE IDENT 
##

expecting an '=' after 'module type $0'.

program: MODULE TYPE IDENT EQUALS SIG MODULE TYPE WITH 
##
## Ends in an error in state: 40.
##
## sig_item -> MODULE TYPE . IDENT EQUALS mod_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## MODULE TYPE 
##

expecting an identifier after 'module' 'type'.

program: MODULE TYPE IDENT EQUALS SIG MODULE WITH 
##
## Ends in an error in state: 39.
##
## sig_item -> MODULE . IDENT functor_type_decls [ TYPE PRED MODULE END CONSTANT ]
## sig_item -> MODULE . TYPE IDENT EQUALS mod_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## MODULE 
##

expecting either 'type' or an identifier after 'module'.

program: MODULE TYPE IDENT EQUALS SIG TYPE IDENT EQUALS WITH 
##
## Ends in an error in state: 32.
##
## sig_type -> TYPE IDENT EQUALS . domain_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## TYPE IDENT EQUALS 
##

expecting a type after the '=' in a type declaration in a module signature.

program: MODULE TYPE IDENT EQUALS SIG TYPE IDENT WITH 
##
## Ends in an error in state: 31.
##
## sig_type -> TYPE IDENT . [ TYPE PRED MODULE END CONSTANT ]
## sig_type -> TYPE IDENT . EQUALS domain_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## TYPE IDENT 
##

after 'type $0' in a module signature, expecting either an '='s followed by a type definition, or a new module signature item.

program: MODULE TYPE IDENT EQUALS SIG TYPE WITH 
##
## Ends in an error in state: 30.
##
## sig_type -> TYPE . IDENT [ TYPE PRED MODULE END CONSTANT ]
## sig_type -> TYPE . IDENT EQUALS domain_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## TYPE 
##

expecting an identifier after the keyword 'type'. An example type declaration in a module signature looks like:
  type tname
or, if this type is not abstract:
  type tname = int * int
where 'tname' is the name of the newly defined type.

program: MODULE TYPE IDENT EQUALS SIG WITH 
##
## Ends in an error in state: 29.
##
## mod_type2 -> SIG . list(sig_item) END [ WITH TYPE RPAREN PRED MODULE EXTERNAL EQUALS EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## SIG 
##

expecting module signature items after 'sig'. FIXME: give some examples.

program: MODULE TYPE IDENT EQUALS WITH 
##
## Ends in an error in state: 28.
##
## str_item -> MODULE TYPE IDENT EQUALS . mod_type [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## MODULE TYPE IDENT EQUALS 
##

expecting a module type after 'module type $1 = ...'. Module types look like: 'sig ...', 'functor ...', or the name of another module type.

program: MODULE TYPE IDENT WITH 
##
## Ends in an error in state: 27.
##
## str_item -> MODULE TYPE IDENT . EQUALS mod_type [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## MODULE TYPE IDENT 
##

expecting an '=' after 'module type <identifier>'.

program: MODULE TYPE WITH 
##
## Ends in an error in state: 26.
##
## str_item -> MODULE TYPE . IDENT EQUALS mod_type [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## MODULE TYPE 
##

expecting an identifier after 'module type'.

program: MODULE WITH 
##
## Ends in an error in state: 25.
##
## str_item -> MODULE . IDENT functor_decls [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
## str_item -> MODULE . TYPE IDENT EQUALS mod_type [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
## str_item -> MODULE . REC separated_nonempty_list(AND,rec_module_binding) [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## MODULE 
##

invalid module declaration. Expecting either an identifier, 'type', or 'rec' after the 'module' keyword.

program: TYPE IDENT EQUALS IDENT DOT WITH 
##
## Ends in an error in state: 17.
##
## longident -> longident DOT . IDENT [ WITH TYPE STAR RPAREN PRED MODULE LPAREN IDENT EXTERNAL EQUALS EOF END DOT DEFINE CONSTANT COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## longident DOT 
##

Expecting an identifier after the '.'.

program: TYPE IDENT EQUALS IDENT END 
##
## Ends in an error in state: 182.
##
## program -> list(str_item) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## list(str_item) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production domain_type0 -> longident 
## In state 19, spurious reduction of production separated_nonempty_list(STAR,domain_type0) -> domain_type0 
## In state 15, spurious reduction of production domain_type -> separated_nonempty_list(STAR,domain_type0) 
## In state 24, spurious reduction of production str_type(IDENT) -> TYPE IDENT EQUALS domain_type 
## In state 142, spurious reduction of production str_item -> str_type(IDENT) 
## In state 143, spurious reduction of production list(str_item) -> 
## In state 144, spurious reduction of production list(str_item) -> str_item list(str_item) 
##

unexpected token after declarations.

program: TYPE IDENT EQUALS IDENT UNDERSCORE 
##
## Ends in an error in state: 16.
##
## domain_type0 -> longident . [ WITH TYPE STAR RPAREN PRED MODULE IDENT EXTERNAL EQUALS EOF END DEFINE CONSTANT AND ]
## longident -> longident . DOT IDENT [ WITH TYPE STAR RPAREN PRED MODULE IDENT EXTERNAL EQUALS EOF END DOT DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## longident 
##

unexpected input after a long identifier.

program: TYPE IDENT EQUALS INT STAR WITH 
##
## Ends in an error in state: 20.
##
## separated_nonempty_list(STAR,domain_type0) -> domain_type0 STAR . separated_nonempty_list(STAR,domain_type0) [ WITH TYPE RPAREN PRED MODULE IDENT EXTERNAL EQUALS EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## domain_type0 STAR 
##

expecting another type after $1 '*' in a tuple type.

program: TYPE IDENT EQUALS INT UNDERSCORE 
##
## Ends in an error in state: 19.
##
## separated_nonempty_list(STAR,domain_type0) -> domain_type0 . [ WITH TYPE RPAREN PRED MODULE IDENT EXTERNAL EQUALS EOF END DEFINE CONSTANT AND ]
## separated_nonempty_list(STAR,domain_type0) -> domain_type0 . STAR separated_nonempty_list(STAR,domain_type0) [ WITH TYPE RPAREN PRED MODULE IDENT EXTERNAL EQUALS EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## domain_type0 
##

expecting either the end of a type, or a '*' followed by another type.

program: TYPE IDENT EQUALS LBRACE ENUM_IDENT BAR WITH 
##
## Ends in an error in state: 8.
##
## separated_nonempty_list(BAR,ENUM_IDENT) -> ENUM_IDENT BAR . separated_nonempty_list(BAR,ENUM_IDENT) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## ENUM_IDENT BAR 
##

expecting an enumeration member name (for example, "`X") after a '|' in an enumeration type.

program: TYPE IDENT EQUALS LBRACE ENUM_IDENT WITH 
##
## Ends in an error in state: 7.
##
## separated_nonempty_list(BAR,ENUM_IDENT) -> ENUM_IDENT . [ RBRACE ]
## separated_nonempty_list(BAR,ENUM_IDENT) -> ENUM_IDENT . BAR separated_nonempty_list(BAR,ENUM_IDENT) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## ENUM_IDENT 
##

expecting either a closing '}' or another enumeration member '| ...' in enumeration type.

program: TYPE IDENT EQUALS LBRACE WITH 
##
## Ends in an error in state: 6.
##
## domain_type0 -> LBRACE . loption(separated_nonempty_list(BAR,ENUM_IDENT)) RBRACE [ WITH TYPE STAR RPAREN PRED MODULE IDENT EXTERNAL EQUALS EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## LBRACE 
##

expecting a '|' separated list of enumeration values after an opening '{'.

program: TYPE IDENT EQUALS LPAREN INT WITH 
##
## Ends in an error in state: 22.
##
## domain_type0 -> LPAREN domain_type . RPAREN [ WITH TYPE STAR RPAREN PRED MODULE IDENT EXTERNAL EQUALS EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## LPAREN domain_type 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 19, spurious reduction of production separated_nonempty_list(STAR,domain_type0) -> domain_type0 
## In state 15, spurious reduction of production domain_type -> separated_nonempty_list(STAR,domain_type0) 
##

after reading the $1 $0, expecting a closing ')' or continuation of the type description.

program: TYPE IDENT EQUALS LPAREN WITH 
##
## Ends in an error in state: 4.
##
## domain_type0 -> LPAREN . RPAREN [ WITH TYPE STAR RPAREN PRED MODULE IDENT EXTERNAL EQUALS EOF END DEFINE CONSTANT AND ]
## domain_type0 -> LPAREN . domain_type RPAREN [ WITH TYPE STAR RPAREN PRED MODULE IDENT EXTERNAL EQUALS EOF END DEFINE CONSTANT AND ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

following an opening '(' in a type expression, expecting a type or a closing parenthesis.

program: TYPE IDENT EQUALS WITH 
##
## Ends in an error in state: 3.
##
## str_type(IDENT) -> TYPE IDENT EQUALS . domain_type [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## TYPE IDENT EQUALS 
##

expecting a type declaration after $2 $1 $0.

program: TYPE IDENT WITH 
##
## Ends in an error in state: 2.
##
## str_type(IDENT) -> TYPE IDENT . EQUALS domain_type [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## TYPE IDENT 
##

expecting an '=' after 'type $0'.

program: TYPE WITH 
##
## Ends in an error in state: 1.
##
## str_type(IDENT) -> TYPE . IDENT EQUALS domain_type [ TYPE MODULE EXTERNAL EOF END DEFINE CONSTANT ]
##
## The known suffix of the stack is as follows:
## TYPE 
##

expecting an identifier after 'type' in a declaration.

program: WITH 
##
## Ends in an error in state: 0.
##
## program' -> . program [ # ]
##
## The known suffix of the stack is as follows:
## 
##

expecting a type, constant, predicate, module, or external predicate definition at the start of the program.


program: MODULE TYPE IDENT EQUALS SIG PRED WITH 
##
## Ends in an error in state: 34.
##
## sig_value -> PRED . IDENT COLON predicate_type [ TYPE PRED MODULE END CONSTANT ]
##
## The known suffix of the stack is as follows:
## PRED 
##

expecting an identifier after $0 in a module signature.
